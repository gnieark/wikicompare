<?php

/**
 * @file
 * Define the function relative to the needs type.
 */

require_once drupal_get_path('module', 'wikicompare') . '/wikicompare_comparative_table.inc';



/*****************************************************************
*
*    MODULE
*
*****************************************************************/

/**
 * Implements hook_node_info().
 * This function create the new node type we need for the module.
 */
function wikicompare_needs_node_info() {
  return array(
    'need' => array(
      'name' => t('Need'),
      'base' => 'need',
      'title_label' => t('Title'),
    ),
  );
}





/*****************************************************************
*
*    CORE_FUNCTIONS
*
*****************************************************************/

/**
 * Add the needs specific fields in db request.
 *
 * @param $query
 *   The query to update. Passed by reference.
 *
 * @param $type
 *   The type of the request.
 */
function wikicompare_needs_request_db($query, $type) {
  if ($type == 'need') {
    $query->addField('nf', 'feature_nid', 'need_feature_id');
    $query->leftjoin('cache_need_feature_rel', 'nf', 'n.nid = nf.need_nid');
  }
}



/**
 * Recover all need_features in an array to use them later.
 *
 * @param $node_array
 *   The node which will be returned. Passed by reference.
 *
 * @param $need_features
 *   The array containing the need_features we will use later. Passed by reference.
 *
 * @param $record
 *   The record from the database.
 *
 * $type
 *   The type of the request.
 */
function wikicompare_needs_request_db_build(&$node_array, &$need_features, $record, $type) {

  if ($type == 'need') {

    if ($record->need_feature_id != NULL) {
      $need_features[$record->nid][$record->need_feature_id] = $record->need_feature_id;
    }

    unset($node_array['data']->need_feature_id);
    //Security to avoid to make isset control later.
    $node_array['need_features'] = array();

  }

}



/**
 * Assign node features to the $res. We couldn't do it  while we were parsing the records.
 *
 * @param $res
 *   The ressource which will be returned. Passed by reference.
 *
 * @param $need_features
 *   The array we build before while we were parsing the records.
 */
function wikicompare_needs_request_db_after(&$res, $need_features) {

  foreach ($need_features as $nid => $features) {
    $res[$nid]['need_features'] = $features;
  }

}





/*****************************************************************
*
*    NODES
*
*****************************************************************/

/**
 * Implements hook_insert().
 * Executed each time a need node is created.
 *
 * @param $node
 *   The node object which was created.
 */
function need_insert($node) {

  //Call the type-agnostic function.
  wikicompare_insert_node('need', $node);

  //Prepare to insert the many2many cache between needs and features.
  $features_m2m = array();
  if (isset($node->wikicompare_features['und'])) {
    foreach ($node->wikicompare_features['und'] as $feature) {
      $feature_m2m[] = array(
        'need_nid' => $node->nid,
        'feature_nid' => $feature['target_id'],
      );
    }
  }

  //Insert the data in the many2many table cache.
  $header = array('need_nid', 'feature_nid');
  if (!empty($feature_m2m)) {
    $query = db_insert('cache_need_feature_rel')->fields($header);
    foreach ($feature_m2m as $record) {
      $query->values($record);
    }
    $query->execute();
  }

}



/**
 * Implements hook_delete().
 * Executed each time a need is deleted.
 *
 * @param $node
 *   The node object which will be deleted.
 */
function need_delete($node) {

  //Call the type-agnostic function.
  wikicompare_delete_node('need', $node);

  //Remove the many2many cache data related to the deleted need.
  db_delete('cache_need_feature_rel')
    ->condition('need_nid', $node->nid)
    ->execute();

}



/**
 * Add the need flag to the array in argument.
 *
 * @param $array
 *   The array to update. Passed by reference.
 */
function wikicompare_needs_node_types(&$array) {

  //Update the array.
  $array[] = 'need';

}



/**
 * Add the need flag to the array in argument.
 *
 * @param $array
 *   The array to update. Passed by reference.
 */
function wikicompare_needs_after_update_fields($node_revision) {

  //Need specific code.
  if ($node_revision->type == 'need') {

    //Get new features.
    $new_feature_ids = array();
    if (isset($node_revision->wikicompare_features['und'])) {
      foreach ($node_revision->wikicompare_features['und'] as $feature) {
        $new_feature_ids[$feature['target_id']] = $feature['target_id'];
      }
    }

    //Get old features, and find the ones we need to delete.
    $to_delete = array();
    $old_feature_ids = array();
    $query = db_select('cache_need_feature_rel', 'f');
    $query->addField('f', 'feature_nid', 'feature_nid');
    $query->condition('f.need_nid', $node_revision->nid);
    $result = $query->execute();
    foreach ($result as $record) {
      $old_feature_ids[$record->feature_nid] = $record->feature_nid;
      if (!in_array($record->feature_nid, $new_feature_ids)) {
        $to_delete[$record->feature_nid] = $record->feature_nid;
      }
    }

    //Find the features we need to create.
    $to_create = array();
    foreach ($new_feature_ids as $feature_id) {
      if (!in_array($feature_id, $old_feature_ids)) {
        $to_create[$feature_id] = array(
          'need_nid' => $node_revision->nid,
          'feature_nid' => $feature_id,
        );
      }
    }

    //Insert the new features in the cache many2many table.
    $header = array('need_nid', 'feature_nid');
    if (!empty($to_create)) {
      $query = db_insert('cache_need_feature_rel')->fields($header);
      foreach ($to_create as $record) {
        $query->values($record);
      }
      $query->execute();
    }

    //Delete the old features in the cache many2many table.
    if (!empty($to_delete)) {
      db_delete('cache_need_feature_rel')
        ->condition('need_nid', $node_revision->nid)
        ->condition('feature_nid', $to_delete, 'in')
        ->execute();
    }

  }

}





/*****************************************************************
*
*    COMPARATIVE TABLE
*
*****************************************************************/

/*
 * Generate the main need itemlist in the wikicompare table.
 *
 * @param $output
 *   The html code which will be send to the user. Passed by reference.
 */
function wikicompare_needs_comparative_table_main_output(&$output) {
  //Call the generic function which generate the main itemlist.
  $output .= wikicompare_table_render_main_itemlist('need', 'Needs', wikicompare_initialize_settings());
}



/*
 * Auto check the already selected needs in main table.
 *
 * @param $nid
 *   The nid of the tested node.
 *
 * @param $nodes
 *   The nodes array which contains the data which will be used in the render itemlist function.
 *
 * @param $_POST
 *   The data coming from the javascript.
 */
function wikicompare_needs_table_prepare_itemlist($nid, &$nodes, $_POST) {

  if (!empty($_POST['selected_need_ids'])) {
    //If the node is in the global variable of the javascript, we mark it to be checked.
    if (in_array($nid, $_POST['selected_need_ids'])) {
      $nodes[$nid]['data']->displayed = True;
    }
  }

}



/*
 * Add the features of the needs to the features which will be used to compute the comparative table.
 *
 * @param $selected_feature_ids
 *   Array containing the features which will be used to compute the comparative table.
 *
 * @param $_POST
 *   The data coming from the javascript.
 *
 * @param $settings
 *   The settings for the db request.
 */
function wikicompare_needs_table_prepare_compute(&$selected_feature_ids, $_POST, $settings) {

  if (!empty($_POST['selected_need_ids'])) {
    //Call the recursive function to add the features. The function must be recursive because we only have the nids of the needs at the base of the tree, and we must also include the features of their parents.
    $selected_feature_ids += wikicompare_needs_recover_features($_POST['selected_need_ids'], $settings);
  }

}



/*
 * Extract features from needs.
 *
 * @param $need_ids
 *   The ids of the needs we want to get the features.
 *
 * @param $settings
 *   The settings for the db request.
 *
 * @return $feature_ids
 *   The ids of the feature we will use for the computation.
 */
function wikicompare_needs_recover_features($need_ids, $settings) {

  //Get the details of the selected needs.
  $needs = request_db('need', array('nids' => $need_ids), $settings);

  $feature_ids = array();
  $parent_ids = array();
  foreach ($needs as $need) {
    //Get features.
    foreach ($need['need_features'] as $fid) {
      $feature_ids[$fid] = $fid;
    }
    //Get parent for the recursive call.
    if ($need['data']->parent_id != NULL) {
      $parent_ids[$need['data']->parent_id] = $need['data']->parent_id;
    }
  }

  if (!empty($parent_ids)) {
    //Recursive call.
    $feature_ids += wikicompare_needs_recover_features($parent_ids, $settings);
  }

  return $feature_ids;

}



/*
 * Add commmand to reset the need part of the table.
 *
 * @param $commands
 *   The commands which will be send to the javascript.
 *
 * @param $settings
 *   The context of the ajax call.
 */
function wikicompare_needs_table_send_compute(&$commands, $settings) {

  //Command to reset table.
  $commands[] = ajax_command_replace('#comparative_table_main_need', wikicompare_table_render_main_itemlist('need', 'Needs', $settings));

}



/*
 * Add commmand to reset the need part of the table.
 *
 * @param $commands
 *   The commands which will be send to the javascript.
 *
 * @param $type
 *   The type of the node
 *
 * @param $reset
 *   If we wan to reset the need
 *
 * @param $settings
 *   The context of the ajax call.
 */
function wikicompare_needs_table_clean_reset(&$commands, $type, $reset, $settings) {

  if ($type == 'need' && $reset == True) {
    $commands[] = ajax_command_replace('#comparative_table_main_need', wikicompare_table_render_main_itemlist('need', 'Needs', $settings));
  }

}





/*****************************************************************
*
*    FORM
*
*****************************************************************/

/**
 * Implements hook_form().
 * We need it to display the title in the node form
 */
function need_form($node, $form_state) {
  return node_content_form($node, $form_state);
}



/**
 * Implements hook_form_TYPE_node_form_alter().
 * This hook allow us to alter the edit form of the node.
 */
function wikicompare_needs_form_need_node_form_alter(&$form, &$form_state, $form_id) {
  //Call type-agnostic function.
  wikicompare_build_form('form', $form, $form_state, 'need');
}



/**
 * Send the features of the need node to javascript file, so we can checked the features by default in the popin.
 *
 * @param $settings
 *   The settings which will be send to javascript. Passed by reference.
 *
 * @param $form_state
 *   The array containing information of the node.
 */
function wikicompare_needs_build_form_settings(&$settings, $form_state) {

  if ($form_state['node']->type == 'need') {

      //Get the features of the need node.
      $selected_feature_ids = array();
      if (isset($form_state['node']->wikicompare_features['und'])) {
        foreach ($form_state['node']->wikicompare_features['und'] as $array) {
          $fid = $array['target_id'];
          $selected_feature_ids[] = $fid;
        }
      }

      //Insert the feature in the settings to send them to javascript.
      $settings['wikicompare_needs']['selected_feature_ids'] = $selected_feature_ids;

  }

}



/**
 * Remove important need fields from translated node.
 *
 * @param $form
 *   The form array which will be used by Drupal to build the node form. Passed by reference.
 *
 * @param $form_state
 *   Array containing in-depth information of the node and form settings. Passed by reference.
 *
 * @param $node
 *   Object containing the detail of the node.
 */
function wikicompare_needs_wikicompare_translation_form(&$form, &$form_state, $node) {

  if (isset($form['need_features'])) {
    unset($form_state['node']->wikicompare_features);
  }

}



/**
 * Add the field specific to need at the end of the form.
 *
 * @param $form
 *   The form array which will be used by Drupal to build the node form. Passed by reference.
 *
 * @param $form_state
 *   Array containing in-depth information of the node and form settings. Passed by reference.
 *
 * @param $output
 *   The HTML code which will be inserted in the comparative table to display the fastaction form. Passed by reference.
 *
 * @param $form_type
 *   Flag defining if the function is called to build a form node of a fastaction form.
 *
 * @param $type
 *   The type of the consulted node.
 *
 * @param $node
 *   Object containing the detail of the node.
 *
 * @param $fastaction
 *   The fastaction (add or edit)
 *
 * @param $nid
 *   The nid of the consulted node.
 */
function wikicompare_needs_build_form(&$form, &$form_state, &$output, $form_type, $type, $node, $fastaction, $nid) {

  if ($type == 'need') {

    $selected_feature_itemlist = '';
    $selected_feature_hidden = '';
    //Get data from object.
    $selected_feature_ids = array();
    if (isset($node->wikicompare_features['und'])) {
      foreach ($node->wikicompare_features['und'] as $array) {
        $fid = $array['target_id'];
        $selected_feature_ids[$fid] = $fid;
      }
    }

    //Build the itemlist from the features of the object.
    $features = array();
    if (!empty($selected_feature_ids)) {
      $settings = wikicompare_initialize_settings(array('context' => 'selected', 'computed' => 1));
      $features = wikicompare_build_recursive_data('feature', $selected_feature_ids, $settings);
      $itemlist_data = wikicompare_build_itemlist('feature', $features['tree'], 0, $settings);
      //Render the item list
      $selected_feature_itemlist = theme_item_list(array('items' => $itemlist_data, 'title' => 'Manually selected features', 'type' => 'ul', 'attributes' => array()));
      foreach ($selected_feature_ids as $feature_id) {
        $selected_feature_hidden .= '<div class="need_feature">' . $feature_id . '</div>';
      }
    }

    //Link which will open a popin where we can select the features.
    $select_feature_link = array(
      'text' => 'Select features',
      'title' => 'Select features',
      'selector' => 'dialog-content',
      'path' => 'wikicompare_get_dialog_callback/multidialog/feature/wikicompare-features/0/',
      'id' => 'select_feature_link',
    );

    if ($form_type == 'form') {
      //The container of the itemlist.
      $form['container_selected_feature'] = array(
        'itemlist' => array('#markup' => $selected_feature_itemlist),
        '#type' => 'container',
        '#id' => 'container-wikicompare-features',
        '#weight' => -2,
      );

      //The link is visible only in the main language node.
      if ($node->language == language_default('language')) {
        $form['container_selected_feature']['#suffix'] = '<div id="initialize_need_features"/><p>' . theme('simple_dialog_link', $select_feature_link) . '</p>';
      }

      //Hide the field from drupal. We can't use the hide() function because it'll block the javascript to update the parent.
      $form['wikicompare_features']['#attributes']['style'] = 'display:none;';
    }

    if ($form_type == 'fastaction') {
      $output .= '<div id="container-wikicompare-features">';
      $output .= $selected_feature_itemlist;
      $output .= '</div><div id="wikicompare-features" style="display:none;">' . $selected_feature_hidden . '</div><p>' . theme('simple_dialog_link', $select_feature_link) . '</p>';
    }

  }

}





/*****************************************************************
*
*    FASTACTION
*
*****************************************************************/



/**
 * Add the fastaction form after the need item.
 *
 * @param $commands
 *   The commands which will be send to javascript. Passed by reference.
 *
 * @param $type
 *   The type of the node.
 *
 * @param $nid
 *   The nid of the node.
 *
 * @param output
 *   The generated form.
 */
function wikicompare_needs_fastaction_command(&$commands, $type, $nid, $output) {

  if ($type == 'need') {
    $commands[] = ajax_command_invoke('#need_table_children_' . $nid, 'before', array($output));
  }

}



/**
 * Assign need specific fields.
 *
 * @param $node
 *   The node which will be submitted. Passed by reference.
 *
 * @param $type
 *   The type of the node.
 *
 * @param $_POST
 *   Variables from javascript.
 */
function wikicompare_needs_fastaction_submit_after(&$node, $type, $_POST) {

  if ($type == 'need') {
    $need_features = array();
    foreach ($_POST['need_feature_ids'] as $feature_id) {
      $array = array();
      $array['target_id'] = $feature_id;
      $array['target_type'] = "node";
      $need_features[] = $array;
    }
    $node->wikicompare_features['und'] = $need_features;
  }

}





/*****************************************************************
*
*    GENERATE DEMO
*
*****************************************************************/

/**
 * Get all needs nodes.
 *
 * @param $output
 *   The html code of the export. Passed by reference.
 */
function wikicompare_needs_demo_export(&$output) {

  $output .= "<p>if (module_exists('wikicompare_needs')) {";
  $output .= "<p>\$needs = array();</p>";
  //Find all the features on the first level of the tree.
  $needs = request_db('need', array('states' => array('draft', 'closed')));
  foreach ($needs as $need) {
    //Get needs children.
    wikicompare_generate_demo_export_output_node($output, $need, 'need');
  }
  $output .= "}</p>";

}



/**
 * Export need specific fields.
 *
 * @param $output
 *   The html code of the export. Passed by reference.
 *
 * @param $type
 *   The type of the node.
 *
 * @param $node
 *   The node we are currently exporting.
 */
function wikicompare_needs_demo_export_specific_fields(&$output, $type, $node) {
  if ($type == 'need') {
    $i = 0;
    $output .= "\$node->wikicompare_features['und'] = array();<br/>";
    foreach($node['need_features'] as $fid) {
      $output .= "\$node->wikicompare_features['und'][" . $i . "]['target_id'] = \$features['new-" . $fid . "'];<br/>";
      $output .= "\$node->wikicompare_features['und'][" . $i . "]['target_type'] = 'node';<br/>";
      $i++;
    }
  }
}



/**
 * Display need specific field in the generate demo form.
 *
 * @param $form
 *   The generate demo form. Passed by reference.
 */
function wikicompare_needs_demo_form(&$form) {

  $form['demo_fieldset']['need_min_depth'] = array(
    '#type' => 'textfield',
    '#title' => t('Minimum need depth'),
    '#default_value' => 0,
    '#size' => 3,
    '#maxlength' => 3,
    '#required' => True,
    '#element_validate' => array('element_validate_integer_positive_or_null'),
  );

  $form['demo_fieldset']['need_max_depth'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum need depth'),
    '#default_value' => 0,
    '#size' => 3,
    '#maxlength' => 3,
    '#required' => TRUE,
    '#element_validate' => array('element_validate_integer_positive_or_null'),
  );

  $form['demo_fieldset']['need_child_min_per_level'] = array(
    '#type' => 'textfield',
    '#title' => t('Minimum number of child need per level'),
    '#default_value' => 0,
    '#size' => 3,
    '#maxlength' => 3,
    '#required' => TRUE,
    '#element_validate' => array('element_validate_integer_positive_or_null'),
  );

  $form['demo_fieldset']['need_child_max_per_level'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum number of child need per level'),
    '#default_value' => 0,
    '#size' => 3,
    '#maxlength' => 3,
    '#required' => TRUE,
    '#element_validate' => array('element_validate_integer_positive_or_null'),
  );

  $form['demo_fieldset']['need_min_feature_per_node'] = array(
    '#type' => 'textfield',
    '#title' => t('Minimum number of features per needs node'),
    '#default_value' => 0,
    '#size' => 3,
    '#maxlength' => 3,
    '#required' => TRUE,
    '#element_validate' => array('element_validate_integer_positive_or_null'),
  );

  $form['demo_fieldset']['need_max_feature_per_node'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum number of features per needs node'),
    '#default_value' => 0,
    '#size' => 3,
    '#maxlength' => 3,
    '#required' => TRUE,
    '#element_validate' => array('element_validate_integer_positive_or_null'),
  );

}



/**
 * Generate need demo data.
 *
 * @param $form_state
 *   The values submitted by the form.
 */
function wikicompare_needs_demo_submit_generate($form_state) {


  $needs_created = array();

  if (($form_state['input']['need_min_depth'] != 0) && ($form_state['input']['need_max_depth'] != 0) && ($form_state['input']['need_child_min_per_level'] != 0) && ($form_state['input']['need_child_max_per_level'] != 0)) {

    $features_without_children = array();

    $query = db_select('cache_feature', 'f');
    $query->addField('f', 'nid', 'nid');
    $query->condition("f.has_children", 0);
    $result = $query->execute();
    foreach($result as $record) {
      $features_without_children[$record->nid] = $record->nid;
    }

    $settings = array(
      'type' => 'need',
      'min_depth' => $form_state['input']['need_min_depth'],
      'max_depth' => $form_state['input']['need_max_depth'],
      'prefix' => 'Need ' . variable_get('wikicompare_next_demo_sequence', 1),
      'child_min_per_level' => $form_state['input']['need_child_min_per_level'],
      'child_max_per_level' => $form_state['input']['need_child_max_per_level'],
      'min_feature_per_node' => $form_state['input']['need_min_feature_per_node'],
      'max_feature_per_node' => $form_state['input']['need_max_feature_per_node'],
      'features_without_children' => $features_without_children,
      'depth' => 1,
    );

    if (module_exists('wikicompare_translation')) {
      //Prepare translation specific settings in the generate demo submit.
      wikicompare_translation_demo_submit_settings($settings, $form_state);
    }

    wikicompare_generate_demo_create_children($settings, $needs_created);

  }

}



/**
 * Generate need specific fields.
 *
 * @param $node
 *   The node we need to modify.
 *
 * @param $settings
 *   The settings of the function.
 */
function wikicompare_needs_demo_submit_specific_fields($node, $settings) {

  if ($settings['type'] == 'need') {

    if (!empty($settings['features_without_children'])) {

      $nb_features = rand($settings['min_feature_per_node'], $settings['max_feature_per_node']);

      if (!in_array($nb_features, array(0,1))) {

        $i_features = 0;
        foreach (array_rand($settings['features_without_children'], $nb_features) as $fid) {
          $node->wikicompare_features['und'][$i_features]['target_id'] = $fid;
          $node->wikicompare_features['und'][$i_features]['target_type'] = "node";
          $i_features++;
        }
        $node->revision = TRUE;
        $node->revision_moderation = TRUE;

        node_save($node);

        _revisioning_publish_latest_revision($node);

      }
    }

  }

}

?>
