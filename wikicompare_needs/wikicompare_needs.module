<?php


require_once drupal_get_path('module', 'wikicompare') . '/wikicompare_comparative_table.inc';

/**
 * Implements hook_node_info().
 * This function create the new node type we need for the module
 */
function wikicompare_needs_node_info() {
  return array(
    'need' => array(
      'name' => t('Need'),
      'base' => 'need',
      'description' => t('TODO : Need description'),
      'help' => t('TODO : Need submission guidelines'),
      'title_label' => t('Title'),
    ),

  );
}









/*****************************************************************
*
*    FORM
*
*****************************************************************/

/**
 * Implements hook_form().
 * We need it to display the title in the node form
 */
function need_form($node, $form_state) {
  return node_content_form($node, $form_state);
}



/**
 * Implements hook_form_TYPE_node_form_alter().
 * This hook allow us to alter the edit form of the node.
 */
function wikicompare_needs_form_need_node_form_alter(&$form, &$form_state, $form_id) {
  //Call type-agnostic function.
  wikicompare_build_form('form', $form, $form_state, 'need');
}



/**
 * Send the features of the need node to javascript file, so we can checked the features by default in the popin.
 *
 * @param $settings
 *   The settings which will be send to javascript. Passed by reference.
 *
 * @param $form_state
 *   The array containing information of the node.
 */
function wikicompare_needs_build_form_settings(&$settings, $form_state) {

  if ($form_state['node']->type == 'need') {

      //Get the features of the need node.
      $selected_feature_ids = array();
      if (isset($form_state['node']->wikicompare_features['und'])) {
        foreach ($form_state['node']->wikicompare_features['und'] as $array) {
          $fid = $array['target_id'];
          $selected_feature_ids[] = $fid;
        }
      }

      //Insert the feature in the settings to send them to javascript.
      $settings['wikicompare_needs']['selected_feature_ids'] = $selected_feature_ids;

  }

}



/**
 * Remove important need fields from translated node.
 *
 * @param $form
 *   The form array which will be used by Drupal to build the node form. Passed by reference.
 *
 * @param $form_state
 *   Array containing in-depth information of the node and form settings. Passed by reference.
 * 
 * @param $node
 *   Object containing the detail of the node.
 */
function wikicompare_needs_wikicompare_translation_form(&$form, &$form_state, $node) {

  if (isset($form['need_features'])) {
    unset($form_state['node']->wikicompare_features);
  }

}



/**
 * Add the field specific to need at the end of the form.
 *
 * @param $form
 *   The form array which will be used by Drupal to build the node form. Passed by reference.
 *
 * @param $form_state
 *   Array containing in-depth information of the node and form settings. Passed by reference.
 * 
 * @param $output
 *   The HTML code which will be inserted in the comparative table to display the fastaction form. Passed by reference.
 *
 * @param $form_type
 *   Flag defining if the function is called to build a form node of a fastaction form.
 *
 * @param $type
 *   The type of the consulted node.
 *
 * @param $node
 *   Object containing the detail of the node.
 *
 * @param $fastaction
 *   The fastaction (add or edit)
 *
 * @param $nid
 *   The nid of the consulted node.
 */
function wikicompare_needs_build_form(&$form, &$form_state, &$output, $form_type, $type, $node, $fastaction, $nid) {

  if ($type == 'need') {

    $selected_feature_itemlist = '';
    $selected_feature_hidden = '';
    //Get data from object.
    $selected_feature_ids = array();
    if (isset($node->wikicompare_features['und'])) {
      foreach ($node->wikicompare_features['und'] as $array) {
        $fid = $array['target_id'];
        $selected_feature_ids[$fid] = $fid;
      }
    }

    //Build the itemlist from the features of the object.
    $features = array();
    if (!empty($selected_feature_ids)) {
      $settings = wikicompare_initialize_settings(array('context' => 'selected', 'computed' => 1));
      $features = wikicompare_build_recursive_data('feature', $selected_feature_ids, $settings);
      $itemlist_data = wikicompare_build_itemlist('feature', $features['tree'], 0, $settings);
      //Render the item list
      $selected_feature_itemlist = theme_item_list(array('items' => $itemlist_data, 'title' => 'Manually selected features', 'type' => 'ul', 'attributes' => array()));
      foreach ($selected_feature_ids as $feature_id) {
        $selected_feature_hidden .= '<div class="need_feature">' . $feature_id . '</div>';
      }
    }

    //Link which will open a popin where we can select the features.
    $select_feature_link = array(
      'text' => 'Select features',
      'title' => 'Select features',
      'selector' => 'dialog-content',
      'path' => 'wikicompare_get_dialog_callback/multidialog/feature/wikicompare-features/0/',//form_selected_features/none',
      'id' => 'select_feature_link',
    );

    if ($form_type == 'form') {
      //The container of the itemlist.
      $form['container_selected_feature'] = array(
        'itemlist' => array('#markup' => $selected_feature_itemlist),
        '#type' => 'container',
        '#id' => 'container-wikicompare-features',
        '#weight' => -2,
      );

      //The link is visible only in the main language node.
      if ($node->language == language_default('language')) {
        $form['container_selected_feature']['#suffix'] = '<div id="initialize_need_features"/><p>' . theme('simple_dialog_link', $select_feature_link) . '</p>';
      }
    }

    if ($form_type == 'fastaction') {
      $output .= '<div id="container-wikicompare-features">';
      $output .= $selected_feature_itemlist;
      $output .= '</div><div id="wikicompare-features" style="display:none;">' . $selected_feature_hidden . '</div><p>' . theme('simple_dialog_link', $select_feature_link) . '</p>';
    }

  }

}





/*****************************************************************
*
*    FASTACTION
*
*****************************************************************/

function wikicompare_needs_fastaction_command(&$commands, $type, $nid, $output) {


  if ($type == 'need') {
    $commands[] = ajax_command_invoke('#need_table_children_' . $nid, 'before', array($output));
  }

}


function wikicompare_needs_fastaction_submit_after(&$node, $type, $_POST) {



  if ($type == 'need') {

    $need_features = array();
    foreach ($_POST['need_feature_ids'] as $feature_id) {
      $array = array();
      $array['target_id'] = $feature_id;
      $array['target_type'] = "node";
      $need_features[] = $array;
    }
    $node->wikicompare_features['und'] = $need_features;


  }

}


/*****************************************************************
*
*    COMPARATIVE TABLE
*
*****************************************************************/

function wikicompare_needs_comparative_table_main_output(&$output) {


  $output .= wikicompare_table_render_main_itemlist('need', 'Needs', wikicompare_initialize_settings()); //wikicompare_needs_table_render_need();

}
/*
function wikicompare_needs_table_render_need($settings=array()) {

  $db_settings = array('can_be_translated' => 1);
  if (isset($settings['states'])) {
    $db_settings['states'] = $settings['states'];
  }

  //Find all the compared on the first level of the tree
  $needs = request_db('need', $db_settings);

  
  $itemlist_settings = wikicompare_initialize_settings();

  if (isset($settings['fastaction'])) {
    $itemlist_settings['fastaction'] = $settings['fastaction'];
  }

  //Building the data for the item list
  $item_list_data = wikicompare_build_itemlist('need', $needs, 0, $itemlist_settings);

  $output ="<div id='comparative_table_main_need'>";
  //Render the item list
  $output .= theme_item_list(array('items' => $item_list_data, 'title' => 'Need', 'type' => 'ul', 'attributes' => array()));
  $output .= '<p><a id="add_need_link" href="?q=node/add/need">Add</a><span id="add_need_link_fastaction">';
 
  if ($itemlist_settings['fastaction']) {
    $need = array(
      'data' => new stdClass(),
    );
    $need['data']->nid = 0;
    $output .= add_fastaction_items('need' , $need);
  }
  $output .= '</span></p>';
  $output .= '<div id="need_table_children_0"></div>';
  $output .="</div>";

  return $output;

}
*/

function wikicompare_needs_table_prepare_itemlist($nid, &$nodes, $_POST) {

  if (!empty($_POST['selected_need_ids'])) {
/*
    $selected_need_ids = array();
    foreach ($_POST['selected_need_ids'] as $selected_need_id) {
      $selected_need_ids[$selected_need_id] = $selected_need_id;
    }
*/
    if (in_array($nid, $_POST['selected_need_ids'])) {
      $nodes[$nid]['data']->displayed = True;
    }

  }

}

function wikicompare_needs_table_prepare_compute(&$selected_feature_ids, $_POST) {

  if (!empty($_POST['selected_need_ids'])) {


    $selected_feature_ids += recover_features($_POST['selected_need_ids']);
/*
    $fids = recover_features($_POST['selected_need_ids']);

    foreach ($feature_ids as $feature_id) {
      $selected_feature_ids[$feature_id] = $feature_id;
    }
*/

  }

}


function recover_features($need_ids) {



/*
  $query = db_select('cache_need', 'n');
  $query->addField('n', 'nid', 'nid');
  $query->addField('n', 'parent_id', 'parent_id');
  $query->addField('f', 'feature_nid', 'feature_id');
  $query->leftjoin('cache_need_feature_rel', 'f', 'n.nid = f.need_nid');
  $query->condition('n.nid', $need_ids, 'in');
  $result = $query->execute();  
*/
  $needs = request_db('need', array('nids' => $need_ids), array());


  $feature_ids = array();
  $parent_ids = array();
  foreach ($needs as $need) {


    if ($need['data']->parent_id != NULL) {
      $parent_ids[$need['data']->parent_id] = $need['data']->parent_id;
    }

    //Prevent sending a null value if the need has no feature. We can't do it directly in the sql query through a where clause because we need to get the parent even if the node has no feature
    foreach ($need['need_features'] as $fid) {
//      if ($need['data']->feature_id != NULL) {
        $feature_ids[$fid] = $fid;
//      }
    }
  }
//TODO Block if parent is disactivated, probably best block the checkbox for children in get_item_list function
  if (!empty($parent_ids)) {
    $feature_ids += recover_features($parent_ids);
/*
    $feature_from_parent_ids = recover_features($parent_ids);


    foreach ($feature_from_parent_ids as $feature_id) {
      $feature_ids[$feature_id] = $feature_id;
    }
*/
  }



  return $feature_ids;

}

function wikicompare_needs_table_send_compute(&$commands, $settings) {

  $commands[] = ajax_command_replace('#comparative_table_main_need', wikicompare_table_render_main_itemlist('need', 'Needs', $settings));

}

function wikicompare_needs_table_clean_reset(&$commands, $type, $reset, $settings) {

  if ($type == 'need' && $reset == True) {
    $commands[] = ajax_command_replace('#comparative_table_main_need', wikicompare_table_render_main_itemlist('need', 'Needs', $settings));
  }

}


/*
function wikicompare_needs_wikicompare_comparative_table_fastaction_parent(&$parent_id, $type, $node) {

  if ($type == 'need') {
    if (isset($node->wikicompare_parent_id['und'])) {
      $parent_id = $node->wikicompare_parent_id['und'][0]['target_id'];
    }
  }

}
*/

/*****************************************************************
*
*    NODES
*
*****************************************************************/

/**
 * Implements hook_insert().
 * Executed each time a need node is created.
 *
 * @param $node
 *   The node object which was created.
 */
function need_insert($node) {

  //Call the type-agnostic function.
  wikicompare_insert_node('need', $node);

  //Prepare to insert the many2many cache between needs and features.
  $features_m2m = array();
  if (isset($node->wikicompare_features['und'])) {
    foreach ($node->wikicompare_features['und'] as $feature) {
      $feature_m2m[] = array(
        'need_nid' => $node->nid,
        'feature_nid' => $feature['target_id'],
      );
    }
  }

  //Insert the data in the many2many table cache.
  $header = array('need_nid', 'feature_nid');
  if (!empty($feature_m2m)) {
    $query = db_insert('cache_need_feature_rel')->fields($header);
    foreach ($feature_m2m as $record) {
      $query->values($record);
    }
    $query->execute();
  }

}



/**
 * Implements hook_delete().
 * Executed each time a need is deleted.
 *
 * @param $node
 *   The node object which will be deleted.
 */
function need_delete($node) {

  //Call the type-agnostic function.
  wikicompare_delete_node('need', $node);

  //Remove the many2many cache data related to the deleted need.
  db_delete('cache_need_feature_rel')
    ->condition('need_nid', $node->nid)
    ->execute();

}



/**
 * Add the need flag to the array in argument.
 *
 * @param $array
 *   The array to update. Passed by reference.
 */
function wikicompare_needs_node_types(&$array) {

  //Update the array.
  $array[] = 'need';

}



/**
 * Add the need flag to the array in argument.
 *
 * @param $array
 *   The array to update. Passed by reference.
 */
function wikicompare_needs_after_update_fields($node_revision) {

  //Need specific code.
  if ($node_revision->type == 'need') {

    //Get new features.
    $new_feature_ids = array();
    if (isset($node_revision->wikicompare_features['und'])) {
      foreach ($node_revision->wikicompare_features['und'] as $feature) {
        $new_feature_ids[$feature['target_id']] = $feature['target_id'];
      }
    }

    //Get old features, and find the ones we need to delete.
    $to_delete = array();
    $old_feature_ids = array();
    $query = db_select('cache_need_feature_rel', 'f');
    $query->addField('f', 'feature_nid', 'feature_nid');
    $query->condition('f.need_nid', $node_revision->nid);
    $result = $query->execute();
    foreach ($result as $record) {
      $old_feature_ids[$record->feature_nid] = $record->feature_nid;
      if (!in_array($record->feature_nid, $new_feature_ids)) {
        $to_delete[$record->feature_nid] = $record->feature_nid;
      }
    }

    //Find the features we need to create.
    $to_create = array();
    foreach ($new_feature_ids as $feature_id) {
      if (!in_array($feature_id, $old_feature_ids)) {
        $to_create[$feature_id] = array(
          'need_nid' => $node_revision->nid,
          'feature_nid' => $feature_id,
        );
      }
    }

    //Insert the new features in the cache many2many table.
    $header = array('need_nid', 'feature_nid');
    if (!empty($to_create)) {
      $query = db_insert('cache_need_feature_rel')->fields($header);
      foreach ($to_create as $record) {
        $query->values($record);
      }
      $query->execute();
    }

    //Delete the old features in the cache many2many table.
    if (!empty($to_delete)) {
      db_delete('cache_need_feature_rel')
        ->condition('need_nid', $node_revision->nid)
        ->condition('feature_nid', $to_delete, 'in')
        ->execute();
    }

  }

}





/*****************************************************************
*
*    CORE_FUNCTIONS
*
*****************************************************************/

/**
 * Add the needs specific fields in db request.
 *
 * @param $query
 *   The query to update. Passed by reference.
 *
 * @param $type
 *   The type of the request.
 */
function wikicompare_needs_request_db($query, $type) {
  if ($type == 'need') {
    $query->addField('nf', 'feature_nid', 'need_feature_id');
    $query->leftjoin('cache_need_feature_rel', 'nf', 'n.nid = nf.need_nid');
  }
}



/**
 * Recover all need_features in an array to use them later.
 *
 * @param $node_array
 *   The node which will be returned. Passed by reference.
 *
 * @param $need_features
 *   The array containing the need_features we will use later. Passed by reference.
 *
 * @param $record
 *   The record from the database.
 *
 * $type
 *   The type of the request.
 */
function wikicompare_needs_request_db_build($node_array, $need_features, $record, $type) {

  if ($type == 'need') {

    if ($record->need_feature_id != NULL) {
      $need_features[$record->nid][$record->need_feature_id] = $record->need_feature_id;
    }

    unset($node_array['data']->need_feature_id);
    //Security to avoid to make isset control later.
    $node_array['need_features'] = array(); 

  }

}



/**
 * Assign node features to the $res. We couldn't do it  while we were parsing the records.
 *
 * @param $res
 *   The ressource which will be returned. Passed by reference.
 *
 * @param $need_features
 *   The array we build before while we were parsing the records.
 */
function wikicompare_needs_request_db_after($res, $need_features) {

  foreach ($need_features as $nid => $features) {
    $res[$nid]['need_features'] = $features;
  }

}





?>
