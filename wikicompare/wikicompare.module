<?php

/**
 * @file
 * TODO Defines a "managed_file" Form API field and a "file" field for Field module.
 */

//TODO  Load all Field module hooks for File.
//require_once DRUPAL_ROOT . '/modules/file/file.field.inc';


//The help page of the module
function wikicompare_help($path, $arg) {

  switch ($path) {
    case "admin/help#wikicompare":
      return '<p>' . t("TODO") . '</p>';
      break;
  }

}


//The configuration page of the module
function wikicompare_admin() {

  $form = array();

  $form['wikicompare_update_compared'] = array(
    '#type' => 'select',
    '#title' => t('Manage parent compared?'),
    '#options' => array(
      'no-update' => t("No update"),
      'update' => t("Update"),
    ),
    '#default_value' => variable_get('wikicompare_update_compared', 'no-update'),
    '#description' => t("Define if the parent compared can also have their own percentage support.<br/> 
In this case, the parent compared will support all the implementation of his children compared, and we will be able to select the parent compared in the comparative table.<br/>
<br/>
Activate this feature can take some time, because the cache table need to be recomputed."),
    '#required' => TRUE,
  );

  $form['#submit'][] = 'submit_settings';

  return system_settings_form($form);

}

//This function handels the submit of the settings form.
function submit_settings($form, $form_state) {
    if ($form_state['input']['wikicompare_update_compared'] == 'update' && variable_get('wikicompare_update_compared', 'no-update') == 'no-update') {

      dpm('Launch cache refresh'); //TODO

    }
}


/**
 * Implements hook_menu().
 * This function create new menu in Drupal
 */
function wikicompare_menu() {

  $items = array();

  //Enable module settings page
  $items['admin/config/wikicompare'] = array(
    'title' => 'Wikicompare module settings',
    'description' => 'Wikicompare module settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wikicompare_admin'),
    'access arguments' => array('administer wikicompare settings'),
    'type' => MENU_NORMAL_ITEM,
   );

  //Enable comparative table URL
  $items['compare'] = array(
    'title' => 'Comparative Table',
    'description' => 'Comparative Table',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wikicompare_comparative_table'),
    'access callback' => TRUE,
    'file' => 'wikicompare_comparative_table.inc',
  );
  return $items;
}



/**
 * Implements hook_node_info().
 * This function create the new node type we need for the module
 */
function wikicompare_node_info() {
  return array(
    'feature' => array(
      'name' => t('Feature'),
      'base' => 'feature',
      'description' => t('TODO : Feature description'),
      'help' => t('TODO : Features submission guidelines'),
      'title_label' => t('Title'),
    ),

    'compared' => array(
      'name' => t('Compared'),
      'base' => 'compared',
      'description' => t('TODO'),
      'help' => t('TODO'),
      'title_label' => t('Title'),
    ),

    'implementation' => array(
      'name' => t('Implementation'),
      'base' => 'implementation',
      'description' => t('TODO'),
      'help' => t('TODO'),
      'title_label' => t('Title'),
    ),


  );
}


/**
 * Implements hook_form().
 * We need it to display the title in the node form
 */
function feature_form($node, $form_state) {
  return node_content_form($node, $form_state);
}


function compared_form($node, $form_state) {
  return node_content_form($node, $form_state);
}


/**
 * Implements hook_insert().
 * Executed each time a feature node is created.
 * When a new feature is created, we also create all the implementation needed, so one for each compared to cross with the feature created
 */
function feature_insert($node) {


  /*
   * Create a new implementation for all compared node
   */

  //Create the new feature in the cache table
  $feature_parent_feature = 0;
  if (isset($node->feature_parent_feature['und'][0])) {
    $feature_parent_feature = $node->feature_parent_feature['und'][0]['target_id'];
  }
  db_insert('cache_feature')
    ->fields(array(
      'nid' => $node->nid,
      'vid' => $node->vid,
      'title' => $node->title,
      'parent_feature_id' => $feature_parent_feature,
      'type' => $node->feature_type['und'][0]['value'],
      'weight' => $node->feature_weight['und'][0]['value'],
      'state' => $node->feature_state['und'][0]['value'],
    ))
    ->execute();

  // Find all compared node. We don't use cache table because node is more reliable for such important task and there is no performance problem here.
  $query = db_select('node', 'n');
  $query->addField('n', 'nid', 'nid');
  $query->addField('cp', 'compared_parent_compared_target_id', 'parent_id');
  $query->leftjoin('field_revision_compared_parent_compared', 'cp', 'n.vid = cp.revision_id');
  $query->condition('n.type', 'compared', '=');
  $result = $query->execute();

  $nids = array();
  foreach ($result as $record) {
    $nids[] = $record;
  }

  $fs_to_insert = array();
  $to_update = array();
  //Create a new implementation node for each compared node
  foreach ($nids as $compared){
    $node_fs = new stdClass();
    $node_fs->type = 'implementation';
    // Add default parameters
    node_object_prepare($node_fs);
    $node_fs->language = LANGUAGE_NONE;
    //Filling entity reference field
    $node_fs->implementation_feature[$node_fs->language][]['target_id'] = $node->nid;
    $node_fs->implementation_feature[$node_fs->language][]['target_type'] = "node";
    $node_fs->implementation_compared[$node_fs->language][]['target_id'] = $compared->nid;
    $node_fs->implementation_compared[$node_fs->language][]['target_type'] = "node";

    node_save($node_fs);

    //Prepare to add the implementation in cache table
    $fs_to_insert[] = array(
      'nid' => $node_fs->nid,
      'vid' => $node_fs->vid,
      'feature_id' => $node_fs->implementation_feature['und'][0]['target_id'],
      'compared_id' => $node_fs->implementation_compared['und'][0]['target_id'],
      'support' => 0,
    );

  }

  //Update the cache_implementation table before the compare tree computation
  if (!empty($fs_to_insert)) {
    $query = db_insert('cache_implementation')->fields(array('nid', 'vid', 'feature_id', 'compared_id', 'support'));
    foreach ($fs_to_insert as $record) {
      $query->values($record);
    }
    $query->execute();
  }

  //Update the compare tree with the new data
  update_compare_tree('feature', array($node->nid), 'update');

}


/**
 * Implements hook_insert().
 * Executed each time a compared node is created.
 * When a new compared is created, we also create all the implementation needed, so one for each feature to cross with the compared created
 */
function compared_insert($node) {


  /*
   * Create a new implementation for all feature node
   */

  //Create the new compared in the cache table
  $compared_parent_compared = 0;
  if (isset($node->compared_parent_compared['und'][0])) {
    $compared_parent_compared = $node->compared_parent_compared['und'][0]['target_id'];
  }
  db_insert('cache_compared')
    ->fields(array(
      'nid' => $node->nid,
      'vid' => $node->vid,
      'title' => $node->title,
      'parent_compared_id' => $compared_parent_compared,
    ))
    ->execute();

  // Find all feature node. We don't use cache table because node is more reliable for such important task and there is no performance problem here.
  $query = db_select('node', 'n');
  $query->addField('n', 'nid', 'nid');
  $query->addField('fp', 'feature_parent_feature_target_id', 'parent_id');
  $query->leftjoin('field_revision_feature_parent_feature', 'fp', 'n.vid = fp.revision_id');
  $query->condition('n.type', 'feature', '=');
  $result = $query->execute();

  $nids = array();
  foreach ($result as $record) {
    $nids[] = $record;
  }


  $fs_to_insert = array();
  $to_update = array();
  //Create a new implementation node for each feature node
  foreach ($nids as $feature){
    $node_fs = new stdClass();
    $node_fs->type = 'implementation';
    // Add default parameters
    node_object_prepare($node_fs);
    $node_fs->language = LANGUAGE_NONE;
    //Filling entity reference field
    $node_fs->implementation_feature[$node_fs->language][0]['target_id'] = $feature->nid;
    $node_fs->implementation_feature[$node_fs->language][0]['target_type'] = "node";
    $node_fs->implementation_compared[$node_fs->language][0]['target_id'] = $node->nid;
    $node_fs->implementation_compared[$node_fs->language][0]['target_type'] = "node";

    //Save the implementation node in database
    node_save($node_fs);

    //Prepare to add the implementation in cache table
    $fs_to_insert[] = array(
      'nid' => $node_fs->nid,
      'vid' => $node_fs->vid,
      'feature_id' => $node_fs->implementation_feature['und'][0]['target_id'],
      'compared_id' => $node_fs->implementation_compared['und'][0]['target_id'],
      'support' => 0,
    );
  }

  //Update the cache_implementation table before the compare tree computation
  if (!empty($fs_to_insert)) {
    $query = db_insert('cache_implementation')->fields(array('nid', 'vid', 'feature_id', 'compared_id', 'support'));
    foreach ($fs_to_insert as $record) {
      $query->values($record);
    }
    $query->execute();
  }

  //Update the compare tree with the new data
  update_compare_tree('compared', array($node->nid), 'update');

}

/**
 * Implements hook_delete().
 * Executed each time a node is deleted.
 * We'll use this hook to delete all the implementation linked to the feature, and force an update on implementation parent on feature axis
 */
function feature_delete($node) {


  /*
   * Delete all implementation linked to the feature
   */

  // Find all implementation node. We can use field_data* field because this field should not be modified so nor have revision. We don't use the cache table because field_data is more reliable.
  $query = db_select('field_data_implementation_feature', 'f');
  $query->addField('f', 'entity_id', 'entity_id');
  $query->condition('f.implementation_feature_target_id', $node->nid, '=');
  $result = $query->execute();

  $nids = array();
  foreach ($result as $record) {
    $nids[] = $record->entity_id;
  }

  // Delete all implementation found
  node_delete_multiple($nids);

  //Delete them in the implementation cache
  db_delete('cache_implementation')
    ->condition('nid', $nids, 'in')
    ->execute();

  //Delete the feature in the feature cache
  db_delete('cache_feature')
    ->condition('nid', $node->nid)
    ->execute();

  //Update cache so all children feature are now without parent
  db_update('cache_feature')
    ->fields(array(
      'parent_feature_id' => 0,
    ))
    ->condition('parent_feature_id', $node->nid)
    ->execute();

  if (isset($node->feature_parent_feature['und'][0])) {
    //Update the compare tree
    update_compare_tree('feature', array($node->feature_parent_feature['und'][0]['target_id']), 'update');
  }

}

/**
 * Implements hook_delete().
 * Executed each time a node is deleted.
 * We'll use this hook to delete all the implementation linked to the compared, and force an update on implementation parent on compared axe
 */
function compared_delete($node) {


  /*
   * Delete all implementation linked to the compared
   */

  // Find all implementation node. We can use field_data* field because this field should not be modified so nor have revision. We don't use cache table because field_data* is more reliable.
  $query = db_select('field_data_implementation_compared', 'c');
  $query->addField('c', 'entity_id', 'entity_id');
  $query->condition('c.implementation_compared_target_id', $node->nid, '=');
  $result = $query->execute();

  $nids = array();
  foreach ($result as $record) {
    $nids[] = $record->entity_id;
  }

  // Delete all implementation found
  node_delete_multiple($nids);

  //Delete them in the implementation cache
  db_delete('cache_implementation')
    ->condition('nid', $nids, 'in')
    ->execute();

  //Delete the compared in the compared cache
  db_delete('cache_compared')
    ->condition('nid', $node->nid)
    ->execute();

  //Update cache so all children feature are now without parent
  db_update('cache_compared')
    ->fields(array(
      'parent_compared_id' => 0,
    ))
    ->condition('parent_compared_id', $node->nid)
    ->execute();

  if (isset($node->compared_parent_compared['und'][0])) {
    //Update the compare tree
    update_compare_tree('compared', array($node->compared_parent_compared['und'][0]['target_id']), 'update');
  }

}

/**
 * Implements hook_revisionapi() provided by revisionning module
 * Executed two time when a node is published, before and after the publishing
 * We'll use this hook to update the compare tree when some value is changed in feature, compared of implementation note
 */
function wikicompare_revisionapi($op, $node_revision) {

  /*
   * Action to do before a node is published
   */
  if ($op == 'pre publish') {

    /*
     * If the node changed is a feature node
     */
    if ($node_revision->type == 'feature') {

      //$node_revision contain the new value, with this load we recover the old value. This way we will be able to know which value was changed, and so know what to do. If a feature node is updated but no critical value is changed, then no update on the compare tree will be done.
      $current_node = node_load($node_revision->nid);


      if ($node_revision->feature_parent_feature) {
        $node_revision_parent = $node_revision->feature_parent_feature['und'][0]['target_id'];
      } else {
        $node_revision_parent = NULL;
      }

      if ($current_node->feature_parent_feature) {
        $current_node_parent = $current_node->feature_parent_feature['und'][0]['target_id'];
      } else {
        $current_node_parent = NULL;
      }

      //If any of the critical field is changed
      if (($node_revision->feature_type['und'][0]['value'] != $current_node->feature_type['und'][0]['value']) || ($node_revision->feature_weight['und'][0]['value'] != $current_node->feature_weight['und'][0]['value']) || ($node_revision->feature_state['und'][0]['value'] != $current_node->feature_state['und'][0]['value']) || ($node_revision_parent != $current_node_parent)) {

        //We mark the feature for update
        db_update('cache_feature')
          ->fields(array(
            'to_update' => 1,
          ))
          ->condition('nid', $node_revision->nid, '=')
          ->execute();

        //If the field parent of the feature was changed, then this is a big part of the compare tree which was changed. We will have to update the previous implementation parent on the feature axis after the leave of the feature child
        if ($node_revision_parent != $current_node_parent) {

          //We mark the old parent and the new parent of the feature for update
          db_update('cache_feature')
            ->fields(array(
              'to_update' => 1,
            ))
            ->condition('nid', array($node_revision_parent, $current_node_parent), 'IN')
            ->execute();

        }
      }
    }

    /*
     * If the node changed is a compared node
     */
    if ($node_revision->type == 'compared') {

      //$node_revision contain the new value, with this load we recover the old value. This way we will be able to know which value was changed, and so know what to do. If a compared node is updated but no critical value is changed, then no update on the compare tree will be done.
      $current_node = node_load($node_revision->nid);

      if ($node_revision->compared_parent_compared) {
        $node_revision_parent = $node_revision->compared_parent_compared['und'][0]['target_id'];
      } else {
        $node_revision_parent = NULL;
      }

      if ($current_node->compared_parent_compared) {
        $current_node_parent = $current_node->compared_parent_compared['und'][0]['target_id'];
      } else {
        $current_node_parent = NULL;
      }

      //If the field parent of the feature was changed, then this is a big part of the compare tree which was changed. We will have to update the previous implementation parent on the feature axis after the leave of the compared child
      if ($node_revision_parent != $current_node_parent) {

        //We mark the updated compared, his old parent and his new parent for update
        db_update('cache_compared')
          ->fields(array(
            'to_update' => 1,
          ))
          ->condition('nid', array($node_revision->nid, $node_revision_parent, $current_node_parent) , 'IN')
          ->execute();


      }

    }

    /*
     * If the node changed is a implementation node
     */
    if ($node_revision->type == 'implementation') {

      //$node_revision contain the new value, with this load we recover the old value. This way we will be able to know which value was changed, and so know what to do. If a feature node is updated but no critical value is changed, then no update on the compare tree will be done.
      $current_node = node_load($node_revision->nid);

      //If the only critical value of a implementation node, the support value, changed, then we will mark this implementation for update
      if ($node_revision->implementation_support['und'][0]['value'] != $current_node->implementation_support['und'][0]['value']) {

          //Mark the implementation for update
          db_update('cache_implementation')
            ->fields(array(
              'to_update' => 1,
            ))
            ->condition('nid', $node_revision->nid, '=')
            ->execute();

      }

    }
  }

  /*
   * Action to do after a node is published
   */
  if ($op == 'post publish') {

    //Update the cache tables with the new values
    if ($node_revision->type == 'feature') {
        $feature_parent_feature = 0;
        if (isset($node_revision->feature_parent_feature['und'][0])) {
          $feature_parent_feature = $node_revision->feature_parent_feature['und'][0]['target_id'];
        }
        db_update('cache_feature')
            ->fields(array(
              'vid' => $node_revision->vid,
              'title' => $node_revision->title,
              'parent_feature_id' => $feature_parent_feature,
              'type' => $node_revision->feature_type['und'][0]['value'],
              'weight' => $node_revision->feature_weight['und'][0]['value'],
              'state' => $node_revision->feature_state['und'][0]['value'],
            ))
            ->condition('nid', $node_revision->nid)
            ->execute();
    }

    if ($node_revision->type == 'compared') {
        $compared_parent_compared = 0;
        if (isset($node_revision->compared_parent_compared['und'][0])) {
          $compared_parent_compared = $node_revision->compared_parent_compared['und'][0]['target_id'];
        }
        db_update('cache_compared')
            ->fields(array(
              'vid' => $node_revision->vid,
              'title' => $node_revision->title,
              'parent_compared_id' => $compared_parent_compared
            ))
            ->condition('nid', $node_revision->nid)
            ->execute();
    }

      if ($node_revision->type == 'implementation') {
        $support = 0;
        if ($node_revision->implementation_support['und'][0]['value'] == 'Supported') {
          $support = 1;
        }
        db_update('cache_implementation')
            ->fields(array(
              'vid' => $node_revision->vid,
              'support' => $support
            ))
            ->condition('nid', $node_revision->nid)
            ->execute();
      }

    //Get all the feature to update
    $query = db_select('cache_feature', 'n');
    $query->addField('n', 'nid', 'nid');
    $query->condition('n.to_update', 1, '=');
    $result = $query->execute();

    $feature_nids = array();
    foreach($result as $item) {
      $feature_nids[$item->nid] = $item->nid;
    }
    //Update all the feature marked. We force the update of the parent because in case of an update thanks to a parent feature change, the implementation percent may not have change but we still need to update their parent.
    if ($feature_nids) {
      update_compare_tree('feature', $feature_nids, 'update');
    }

    //Get all the compared to update
    $query = db_select('cache_compared', 'n');
    $query->addField('n', 'nid', 'nid');
    $query->condition('n.to_update', 1, '=');
    $result = $query->execute();

    $compared_nids = array();
    foreach($result as $item) {
      $compared_nids[$item->nid] = $item->nid;
    }
    //Update all the compared marked. We force the update of the parent because in case of an update thanks to a parent compared change, the implementation percent may not have change but we still need to update their parent.
    if ($compared_nids) {
      update_compare_tree('compared', $compared_nids, 'update');
    }

    //Get all the implementation to update
    $query = db_select('cache_implementation', 'n');
    $query->addField('n', 'nid', 'nid');
    $query->condition('n.to_update', 1, '=');
    $result = $query->execute();

    $implementation_nids = array();
    foreach($result as $item) {
      $implementation_nids[$item->nid] = $item->nid;
    }

    //Update all the implementation marked. We force the update of the parent because in case of an update thanks to a parent feature or compared change, the implementation percent may not have change but we still need to update their parent.
    if ($implementation_nids) {
      update_compare_tree('implementation', $implementation_nids, 'update');
    }

    //Remove all update marks
    if (!empty($feature_nids)) {
      db_update('cache_feature')
        ->fields(array(
          'to_update' => 0,
        ))
        ->condition('nid', $feature_nids, 'IN')
        ->execute();
    }

    if (!empty($compared_nids)) {
      db_update('cache_compared')
        ->fields(array(
          'to_update' => 0,
        ))
        ->condition('nid', $compared_nids, 'IN')
        ->execute();
    }

    if (!empty($implementation_nids)) {
      db_update('cache_implementation')
        ->fields(array(
          'to_update' => 0,
        ))
        ->condition('nid', $implementation_nids, 'IN')
        ->execute();
    }

  }
}





 /*
  * The main function to update the percent and css_class for each implementation
  * It'll find all children on compared and feature axis for the ids passed in argument, compute the percent thanks to theses informations and feature type, and finally if the percent changed it'll update the parents on feature and compared axis.
  * This is a recursive function, which will call itself on children side if a cache percent is missing and parent side if the percent computed change, and in both the feature and compared axis.
  */
function update_compare_tree($type, $nids, $update_parent) {

  $nodes = array();
  if (!empty($nids)) {

    $query = db_select('cache_implementation', 'fs');
    $query->addField('fs', 'nid', 'nid');
    $query->addField('nf', 'nid', 'fid');
    $query->addField('nc', 'nid', 'cid');
    $query->addField('fs', 'support', 'support');	
    $query->addField('nf', 'type', 'type');
    $query->addField('nf', 'parent_feature_id', 'parent_feature_id');
    $query->addField('nc', 'parent_compared_id', 'parent_compared_id');
    $query->addField('nfpnf', 'nid', 'parent_fs_through_feature_nid');
    $query->addField('ncpnc', 'nid', 'parent_fs_through_compared_nid');

    //Get parent implementation through feature axis
    $query->join('cache_feature', 'nf', 'fs.feature_id = nf.nid'); //Get feature node
    $query->leftjoin('cache_implementation', 'nfpnf', 'nf.parent_feature_id = nfpnf.feature_id'); //Get implementation of the parent feature node

    //Get parent implementation through feature axis
    $query->join('cache_compared', 'nc', 'fs.compared_id = nc.nid'); //Get compared node
    $query->leftjoin('cache_implementation', 'ncpnc', 'nc.parent_compared_id = ncpnc.compared_id'); //Get implementation of the parent compared node

    //If possible, we search directly through feature or compared id to compute the sql request faster
    switch ($type) {
      case "implementation":
        $query->condition('fs.nid', $nids, 'IN');
        break;
      case "feature":
        //Recover children of implementation on compared axis, because we will only update implementation which has no children on compared axis
        $query->leftjoin('cache_compared', 'ncc', 'fs.compared_id = ncc.parent_compared_id'); //Get compared node children
        $query->where('ncc.nid IS NULL'); //Only the implementation without children on compared axis need to be updated, because they will update their parent on compared axis anyway
        $query->condition('nf.nid', $nids, 'IN');
        break;
      case "compared":
        //Recover children of implementation on feature axis, because we will only update implementation which has no children on feature axis
        $query->leftjoin('cache_feature', 'nfc', 'fs.feature_id = nfc.parent_feature_id'); //Get feature node children
        $query->where('nfc.nid IS NULL'); //Only the implementation without children on feature axis need to be updated, because they will update their parent on feature axis anyway
        $query->condition('nc.nid', $nids, 'IN');
        break;
    }

    $query->where('nfpnf.compared_id = nc.nid OR nf.parent_feature_id = 0'); //We keep only the implementation of the parent feature node which has the same compared than the implementation. Which mean it's the parent implementation on the feature axis.
    $query->where('ncpnc.feature_id = nf.nid OR nc.parent_compared_id = 0'); //We keep only the implementation of the parent compared node which has the same feature than the implementation. Which mean it's the parent implementation on the compared axis.
    $result = $query->execute();


    $implementation_ids = array();
    $res_search_feature_children = '';
    $res_search_compared_children = '';
    foreach($result as $record) {
      //Using $record->nid as key allow deduplication of the id in argument array
      $nodes[$record->nid] = $record;
      $implementation_ids[$record->nid] = $record->nid;

      //Build the where argument for the later get children query
      if ($res_search_feature_children) {
        $res_search_feature_children = $res_search_feature_children . ',';
      }
      $res_search_feature_children = $res_search_feature_children . "('" . $record->fid . "','" . $record->cid . "')";

      if ($res_search_compared_children) {
        $res_search_compared_children = $res_search_compared_children . ',';
      }
      $res_search_compared_children = $res_search_compared_children . "('" . $record->cid . "','" . $record->fid . "')";
    }

    $through_feature_childs = array();
    //We don't need the children through feature child in case of type = 'compared'. Also, we should not call this function if $res_search_feature_children is used and null, otherwise it'll crash.
    if ($type == 'feature' || ($type == 'implementation' && $res_search_feature_children)) {
      //Get children implementation through feature axis
      $query = db_select('cache_implementation', 'fs');
      $query->addField('fs', 'nid', 'nid');
      $query->addField('fs', 'feature_id', 'fid');
      $query->addField('fs', 'compared_id', 'cid');
      $query->addField('nf','parent_feature_id', 'parent_fid');
      $query->addField('ctc', 'nid', 'cache_nid');
      $query->addField('ctc', 'percent', 'percent');
      $query->addField('nf', 'weight', 'weight');

      //Get parent feature
      $query->leftjoin('cache_feature', 'nf', 'fs.feature_id = nf.nid');	

      //Get the percent computed of the children, if already computed
      $query->leftjoin('cache_comparative_table', 'ctc', 'fs.nid = ctc.nid');	

      switch ($type) {
        case "implementation":
          //We keep only the implementation of the child feature node which has the same compared than the implementation. Which mean it's the children implementation on the feature axis.
          $query->where('(nf.parent_feature_id, fs.compared_id) IN (' . $res_search_feature_children . ')');
          break;
        case "feature":
          $query->condition('nf.parent_feature_id', $nids, 'IN');
          break;
      }

      //Only published feature are used in their parent computation
      $query->condition('nf.state', 'Published', '=');
      $result = $query->execute();

      $through_feature_childs = array();
      foreach($result as $record) {
        //We assign the children implementation in a array with fid and cid as key so their parents can recover them with fid and cid key
        $through_feature_childs[$record->parent_fid][$record->cid][$record->nid] = $record;
      }

    }


    $through_compared_childs = array();

    //We don't need the children through compared child in case of type = 'feature'. Also, we should not call this function if $res_search_feature_children is used and null, otherwise it'll crash.
    if ($type == 'compared' || ($type == 'implementation' && $res_search_compared_children)) {

      //Get children implementation through feature axis
      $query = db_select('cache_implementation', 'fs');
      $query->addField('fs', 'nid', 'nid');
      $query->addField('fs', 'feature_id', 'fid');
      $query->addField('fs', 'compared_id', 'cid');
      $query->addField('nc','parent_compared_id', 'parent_cid');
      $query->addField('ctc', 'nid', 'cache_nid');
      $query->addField('ctc', 'percent', 'percent');
      $query->addField('ctc', 'css_class', 'css_class');

      //Get parent compared
      $query->leftjoin('cache_compared', 'nc', 'fs.compared_id = nc.nid');

      //Get the percent computed of the children, if already computed
      $query->leftjoin('cache_comparative_table', 'ctc', 'fs.nid = ctc.nid');

      switch ($type) {
        case "implementation":
          //We keep only the implementation of the child compared node which has the same feature than the implementation. Which mean it's the children implementation on the compared axis.
          $query->where('(nc.parent_compared_id, fs.feature_id) IN (' . $res_search_compared_children . ')');
          break;
        case "compared":
          $query->condition('nc.parent_compared_id', $nids, 'IN');
          break;
      }

      $result = $query->execute();

      $through_compared_childs = array();
      foreach($result as $record) {
        //We assign the children implementation in a array with fid and cid as key so they parent can recover them with fid and cid key
        $through_compared_childs[$record->parent_cid][$record->fid][$record->nid] = $record;
      }

    }

    //Assign children to each node to compute. Also, if a children is not already computed we mark it to update
    $to_update = array();
    foreach($nodes as $node) {
      $node->through_feature_childs = array();
      if (isset($through_feature_childs[$node->fid][$node->cid])) {
        //Assign the children thanks to fid and cid key
        $node->through_feature_childs = $through_feature_childs[$node->fid][$node->cid];
        foreach($through_feature_childs[$node->fid][$node->cid] as $child) {
          if (!$child->cache_nid) {
            //If the children isn't already computed, we mark it to update
            $to_update_feature_childs[$child->nid] = $child->nid;
          }
        }
      }
      $node->through_compared_childs = array();
      if (isset($through_compared_childs[$node->cid][$node->fid])) {
        //Assign the children thanks to fid and cid key
        $node->through_compared_childs = $through_compared_childs[$node->cid][$node->fid];
        foreach($through_compared_childs[$node->cid][$node->fid] as $child) {
          if (!$child->cache_nid) {
            //If the children isn't already computed, we mark it to update
            $to_update_compared_childs[$child->nid] = $child->nid;
          }
        }
      }
    }





    if (!empty($to_update_feature_childs)) {
      //Update the children on feature axis with the flag no-update-feature. This flag ensure it'll not try to update parent on the same axis than the one we use here
      $res = update_compare_tree('implementation', $to_update_feature_childs, 'no-update-feature');
      foreach($nodes as $node) {
        foreach($node->through_feature_childs as $key => $child) {
          //Update_compare_tree function return percent and css_class value of the implementation computed in array, we use it to update our children
          if (isset($res[$key])) {
            $child->percent = $res[$key]['percent'];
            $child->css_class = $res[$key]['css_class'];
          }
        }
      }
    }


    if (!empty($to_update_compared_childs)) {
      //Update the children on compared axis with the flag no-update-compared. This flag ensure it'll not try to update parent on the same axis than the one we use here
      $res = update_compare_tree('implementation', $to_update_compared_childs, 'no-update-compared');
      foreach($nodes as $node) {
        foreach($node->through_compared_childs as $key => $child) {
          //Update_compare_tree function return percent and css_class value of the implementation computed in array, we use it to update our children
          if (isset($res[$key])) {
            $child->percent = $res[$key]['percent'];
            $child->css_class = $res[$key]['css_class'];
          }
        }
      }
    }
  }


  //Recover the existing cache value only now and not in the first SQL request, because their value may be updated during the children update
  if ($implementation_ids) {
    $query = db_select('node', 'fs');
    $query->addField('fs', 'nid', 'nid');
    $query->addField('ctc', 'nid', 'cache_nid');
    $query->addField('ctc', 'percent', 'cache_percent');
    $query->addField('ctc', 'css_class', 'cache_css_class');
    $query->leftjoin('cache_comparative_table', 'ctc', 'fs.nid = ctc.nid');
    $query->condition('fs.nid', $implementation_ids, 'IN');
    $result = $query->execute();
  }

  foreach($result as $record) {
    $nodes[$record->nid]->cache_nid = $record->cache_nid;
    $nodes[$record->nid]->cache_percent = $record->cache_percent;
    $nodes[$record->nid]->cache_css_class = $record->cache_css_class;
  }



  /*
   * Now we'll compute the percent and css_class of each nids in function argument
   */
  $to_update = array();
  $cache_to_update = array();
  $cache_to_insert = array();
  $res = array();
  foreach($nodes as $node) {

    //If any misconfiguration (For exemple a feature of type weight-average but without feature children), it'll always return 0
    $node->percent = 0;
    $node->css_class = 'cell-support-no';

    //If the feature is of type not parent feature, it'll use the support field to know what value return
    if ($node->type == 'not-parent-feature') {

      //We only update with support field if there is no compared children
      if (empty($node->through_compared_childs)) {
        if ($node->support == 1) {
          $node->percent = 100;
          $node->css_class = 'cell-support-complete';
        } else {
          $node->percent = 0;
          $node->css_class = 'cell-support-no';
        }
      }

    //If the feature is of type weighted average, it'll use the children through feature axis to compute the percent
    } elseif ($node->type == 'parent-weighted-average') {

      $total = 0;
      $count = 0;
      foreach($node->through_feature_childs as $child) {
        $total += $child->percent * $child->weight;
        $count += $child->weight;
      }

      //Security to avoid the divided by 0
      if ($count == 0) {
        $count = 1;
      }

      $node->percent = round(($total / $count),4);
      $node->css_class = find_css_class($node->percent);

    //If the feature is of type hightest percentage, it'll use the children through feature axis to compute the percent
    } elseif ($node->type == 'parent-hightest-percentage') {

      $node->percent = 0;
      $node->css_class = 'cell-support-no';
      foreach($node->through_feature_childs as $child) {

          //Security if weight field is misconfigured
          if ($child->weight > 100) {
            $child->weight = 100;
          }

          //Compute the value for this children.
          $child_percent = round(($child->percent * $child->weight / 100), 4);
          //If percent for this children is highter, then it'll be the value computed
          if ($child_percent >= $node->percent) {
            $node->percent = $child_percent;
          }

      }
      $node->css_class = find_css_class($node->percent);

    }

    //If a children through compared axis is higher than the value computed, then it'll be used instead
    foreach($node->through_compared_childs as $child) {

      if ($child->percent >= $node->percent) {
        $node->percent = $child->percent;
        $node->css_class = $child->css_class;
      }

    }


    //Update the value computed in database, only if the value changed
    if (!(($node->percent == $node->cache_percent) && ($node->css_class == $node->cache_css_class))) {
      if ($node->cache_nid) {
        //We regroup all the same percent in a table to update them all at the same time
        $cache_to_update[$node->css_class][$node->percent][] = $node->nid;
      } else {
        //We regroup all the same percent in a table to insert them all at the same time
        $cache_to_insert[$node->css_class][$node->percent][] = $node->nid;
      }
    }

    //Update the parent though feature and compared axis if the value changed, or if we have the flag force-update. Above, we rounded the percent computed to 4 because it'll be the same rounding than the one in database. This ensure this comparison work correctly and don't update parent if unnecessary
    if (!(($node->percent == $node->cache_percent) && ($node->css_class == $node->cache_css_class))) {

      //We mark the parent id through feature axis to update if exist, unless we have the flag no-update-feature. This flag deny the parent update through feature axis if update_compare_tree was launched for a children computation
      if (($node->parent_fs_through_feature_nid) && ($update_parent != 'no-update-feature')) {
        $to_update[$node->parent_fs_through_feature_nid] = $node->parent_fs_through_feature_nid;
      }

      //We mark the parent id through compared axis to update if exist, unless we have the flag no-update-compared. This flag deny the parent update through compared axis if update_compare_tree was launched for a children computation
      if (($node->parent_fs_through_compared_nid) && ($update_parent != 'no-update-compared')) {
        $to_update[$node->parent_fs_through_compared_nid] = $node->parent_fs_through_compared_nid;
      }

    }

    //Fill the res variable the function will return
    $res[$node->nid]['percent'] = $node->percent;
    $res[$node->nid]['css_class'] = $node->css_class;

  }

  //Insert the new records in database. Data are regrouped by css and percent to try to make as few query as possible.
  foreach($cache_to_insert as $key_css_class => $css_class) {
    foreach($cache_to_insert[$key_css_class] as $key_percent => $percent) {
      $query = db_insert('cache_comparative_table')->fields(array('nid', 'percent', 'css_class'));
      foreach ($cache_to_insert[$key_css_class][$key_percent] as $nid) {
        $query->values(array(
          'nid' => $nid,
          'percent' => $key_percent,
          'css_class' => $key_css_class,
        ));
      }
      $query->execute();
    }
  }
  //Update the old records. Data are regrouped by css and percent to try to make as few query as possible.
  foreach($cache_to_update as $key_css_class => $css_class) {
    foreach($cache_to_update[$key_css_class] as $key_percent => $percent) {
        db_update('cache_comparative_table')
          ->fields(array(
            'percent' => $key_percent,
            'css_class' => $key_css_class,
          ))
          ->condition('nid', $cache_to_update[$key_css_class][$key_percent], 'IN')
          ->execute();
    }
  }

  //Update the parent marked
  if (!empty($to_update)) {
    update_compare_tree('implementation', $to_update, 'update');
  }

  return $res;

}

/*
 * Function used to computed the css_class according to the percent value
 */
function find_css_class($percent) {

  if ($percent ==0) {
    $css_class = 'cell-support-no';
  } elseif (($percent > 0) && ($percent < 10)) {
    $css_class = 'cell-support-partial-0-10';
  } elseif (($percent >= 10) && ($percent < 20)) {
    $css_class = 'cell-support-partial-10-20';
  } elseif (($percent >= 20) && ($percent < 30)) {
    $css_class = 'cell-support-partial-20-30';
  } elseif (($percent >= 30) && ($percent < 40)) {
    $css_class = 'cell-support-partial-30-40';
  } elseif (($percent >= 40) && ($percent < 50)) {
    $css_class = 'cell-support-partial-40-50';
  } elseif (($percent >= 50) && ($percent < 60)) {
    $css_class = 'cell-support-partial-50-60';
  } elseif (($percent >= 60) && ($percent < 70)) {
    $css_class = 'cell-support-partial-60-70';
  } elseif (($percent >= 70) && ($percent < 80)) {
    $css_class = 'cell-support-partial-70-80';
  } elseif (($percent >= 80) && ($percent < 90)) {
    $css_class = 'cell-support-partial-80-90';
  } elseif (($percent >= 90) && ($percent < 100)) {
    $css_class = 'cell-support-partial-90-100';
  } elseif (($percent == 100)) {
    $css_class = 'cell-support-complete';
  }

  return $css_class;

}


/**
 * Implements hook_theme().
 */
function wikicompare_theme() {
  return array(
    // Theme function for the compare table
    'wikicompare_comparative_table' => array(
      'render element' => 'form',
      'file' => 'wikicompare_comparative_table.inc',
    ),
  );
}


?>
